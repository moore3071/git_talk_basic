---
redirect_from: "/"
---
<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Git and Github- The basics</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/blood.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>The Basics of Git</h1>
					<h3>An interactive introduction to Git and Github</h3>
					<p>
						<small>Sponsored by the OpenSource Club</small>
					</p>
				</section>

				<section>
					<section>
						<h2>What you should have with you</h2>
						<ul>
							<li>A computer</li>
							<li>Access to a Unix-based terminal</li>
							<li>Git installed <small>check with `git --version`</small></li>
							<li>A Github account</li>
						</ul>
					</section>
					<section>
						<h2>Installing git</h2>
						<table>
							<tr>
								<th>Distro</th><th>Command</th>
							</tr>
							<tr>
								<td>Debian-based</td><td>#apt-get install git</td>
							</tr>
							<tr>
								<td>Redhat-based based</td><td>#yum install git</td>
							</tr>
							<tr>
								<td>Fedora(22 and on)</td><td>#dnf install git</td>
							</tr>
							<tr>
								<td>Arch</td><td>#pacman -S git</td>
							</tr>
							<tr>
								<td>Gentoo</td><td>#emerge dev-vcs/git</td>
							</tr>
							<tr>
								<th> OS </th><th>Command</th>
							</tr>
							<tr>
								<td> Mac </td> <td> $git #then follow instructions</td>
							</tr>
							<tr>
								<td> Windows </td> <td> http://git-scm.com/download/win </td>
							</tr>
						</table>
					</section>
					<section>
						<h2>Signing up with GitHub</h2>
						<a href="https://github.com"><img src="github_signup.png" alt="https://github.com"></img></a>
					</section>
				</section>

				<section>
					<section>
						<h2>Traditional approach to Git</h2>
						<img src="xkcd_git.png"></img>
					</section>
					<section>
						<h2>Git is quicksaving</h2>
						<img src="explosmquicksave.png"></img>
					</section>
					<section>
						<h2> Git as quicksaving </h2>
						<table>
							<tr><td>Commit</td><td>Save</td></tr>
							<tr><td>Branches</td><td>Different choices</td></tr>
							<tr><td>Remotes</td><td>Saves from other people</td></tr>
						</table>
					</section>
					<section>
						<h2> Where the analogy breaks </h2>
						<ul>
							<li>Saves(commits) are easily combined with the saves(commits) from other choices</li>
							<li>People are usually sharing their saves(commits)</li>
							<li>You have to specify what to save</li>
						</ul>
					</section>
				</section>

				<section>
					<section>
						<h2>Let's start using Git</h2>
						<ol>
							<li> make a directory for today's repos <code> $mkdir git_talk_repos</code></li>
							<li> go to this directory <code> $cd git_talk_repos</code></li>
							<li> Fork the repo at github.com/octocat/Spoon-Knife  on the website GitHub</li>
							<li> Clone the repository to your copy <code> git clone https://github.com/userName/Spoon-Knife.git</code></li>
							<li> Add the remote "upstream" to your local version <code> git remote add upstream https://github.com/octocat/Spoon-Knife.git</code></li>
						</ol>
					</section>
					<section>
						<h1>What did we just do?</h1>
						<ul>
							<li> Forking </li>
							<li> Cloning </li>
							<li> Remotes </li>
						</ul>
					</section>
					<section>
						<h2>Forking</h2>
						<p> <b>You (generally) can't write to repos you don't own on Github</b>. Forking gives you a version of the code also on Github that you can maintain and modify</p>
					</section>
					<section>
						<h2>Cloning</h2>
						<p>Cloning puts the project on your computer and allows you to commnicate with the repo you cloned.</p>
					</section>
					<section>
						<h2>Remotes</h2>
						<p>different sources from which you get your code. Generally if you've forked a project you'll need to get more up to date  versions of the code from the original repo (usually the upstream remote).</p>
					</section>
				</section>

				<section>
					<section>
						<h2>Visualizing Git</h2>
					</section>
					<section>
						<h2>A repo is represented as a graph</h2>
						<pre>
     A--B--C--D topic                       A--B--C--D topic
    /                       --&gt;            /          \
E--F--G--H--I--J master                E--F--G--H--I---J master
						</pre>
						<p>Each letter represents a commit, and different lines represent different branches</p>
					</section>
					<section>
						<h2> remotes </h2>
						<pre>
origin                                  upstream

     A--B--C--D topic HEAD                     
    /                                          
E--F--G--H--I master                    E--F--G--H--I--J--K master

refs
|
&gt;---remotes
    |
    &gt;---origin
    |   |
    |   &gt;---master
    |   &gt;---topic
    |   &gt;---HEAD
    |
    &gt;---upstream
    |   |
    |   &gt;---master
						</pre>
						<p>Info from remotes is stored locally, and is udpated using git fetch. </p>
					</section>
				</section>

				<section>
					<section>
						<h2>What's on your computer vs what's on the server</h2>
						<p>One good question is what differentiates your repository on your computer from the remotes you interact with? The two are different:</p>
						<ul>
							<li>Remote repos: are bare</li>
							<li>Local repos: have a HEAD and working tree</li>
						</ul>
						<p>HEAD: the commit where you are</p>
					</section>
				</section>

				<section>
					<h2>Common Git commands</h2>
					<ul>
						<li>git add</li>
						<li>git rm</li>
						<li>git commit</li>
						<li>git fetch</li>
						<li>git merge</li>
						<li>git pull</li>
						<li>git rebase</li>
					</ul>
				</section>

				<section>
					<section>
						<h2>Git add</h2>
						<code>$git add &lt;file&gt;</code>
						<p>Adds a modified or new file to be staged in order to be committed.</p>
					</section>
					<section>
						<pre>
$git status
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   index.html

						</pre>
						<pre>
$git add index.html; git status;
						</pre>
						<pre>
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	modified:   index.html
						</pre>
					</section>
				</section>

				<section>
					<section>
						<h2>Git rm</h2>
						<code>$git rm &lt;file&gt;</code>
						<p>Stages a file to be removed in the next commit.</p>
					</section>
					<section>
						<pre>
$ls
unnecessary_file   src/    README.md
$git status
On branch master
nothing to commit, working directory clean
$git rm unnecessary_file
rm 'unnecessary_file'
$git status
Changes to be committed:
   (use "git reset HEAD &lt;file&gt;..." to unstage)

      deleted:   unnecessary_file
						</pre>
					</section>
				</section>

				<section>
					<section>
						<h2>Git commit</h2>
						<code>$git commit &lt;remote&gt; &lt;branch&gt;</code>
						<p>Makes a "save" of the currently staged changes</p>
					</section>
					<section>
						<pre>
$git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	modified:   index.html
        deleted:    unnecessary_file
$git commit -m "Removed unnecessary_file, and updated index"
[master 2d1de69] Removed unnecessary_file, and updated index"
1 file changed, 1 file deleted, 87 insertions(+), 8 deletions(-)
$
						</pre>
					</section>
				</section>

				<section>
					<section>
						<h2>Git fetch</h2>
						<code>$git fetch &lt;remote&gt; &lt;branch&gt;</code>
						<p>Retrieves the state of &lt;branch&gt; in the remote repository &lt;remote&gt; which can then be compared with the local repository</p>
					</section>
					<section>
						<p>Git fetch should be used to check what has changed outside of your own machine</p>
					</section>
				</section>

				<section>
					<section>
						<h2>Git merge</h2>
						<code>$git merge &lt;branch&gt;</code>
						<p>Merges the changes from &lt;branch&gt; into the current branch and moves the current branch's pointer to the merged commit. Note that the pointer for &lt;branch&gt; remains where it was before.</p>
					</section>
				</section>

				<section>
					<section>
						<h2>Git pull</h2>
						<code>$git pull &lt;remote&gt; &lt;branch&gt;</code>
						<p>Runs a combination of git fetch and git merge. First it fetches the changes from &lt;remote&gt; &lt;branch&gt; and merges them into your local branch of the name &lt;branch&gt; (creating it if it doesn't exist).</p>
					</section>
				</section>

				<section>
					<section>
						<h2>Git reset</h2>
						<code>$git reset --hard &lt;commit-sha&gt;</code>
						<p>Bring head back to a specific commit or HEAD(gets rid of all staged changes)</p>
						<code>$git reset &lt;file&gt;</code>
						<p>Unstages a file that is staged for commit</p>
					</section>
				</section>
				<section>
					<section>
						<h2>Git revert</h2>
						<code>$git revert &lt;commit-sha&gt;</code>
						<p>Get rid of the changes made in a specific commit</p>
					</section>
				</section>

				<section>
					<section>
						<h2> Merge conflicts </h2>
						<p> One of the most feared terms in version control is 'merge conflict'. Don't automatically delete your repo though. We can still work through this</p>
					</section>
					<section>
						<h4>I'll do this example in the presentation <small> but I should add an example later</small>
				</section>

				<section>
					<h1> Basic workflows on Github </h1>
					<ul>
						<li>Naive approach</li>
						<li>Branch and merge</li>
						<li>Fork and merge</li>
						<li>Pull requests</li>
					</ul>
				</section>

				<section>
					<section>
						<h2>Naive approach</h2>
						<table>
							<caption>Situation</caption>
							<tr><td>Remotes</td><td> 1</td></tr>
							<tr><td>Branches</td><td> 1</td></tr>
						</table>
					</section>
					<section>
						<table>
							<tr> <th> Pros </th> <th> Cons </th> </tr>
							<tr>
								<td> Simple </td>
								<td> More frequent merge conflicts </td>
							</tr>
							<tr>
								<td> </td>
								<td> Requires everyone has write access </td>
							</tr>
							<tr>
								<td></td>
								<td>Master/production can be disabled for time </td>
							</tr>
						</table>
					</section>
					<section>
						<h2>Summary</h2>
						<p>The naive approach is ideal for simple projects involving one user (think version controlling your school notes and homework), but is extremely problematic for most other projects.</p>
					</section>
				</section>
				<section>
					<section>
						<h2>Branch and merge</h2>
						<table>
							<caption> Situation </caption>
							<tr><td>Remotes</td><td> 1 </td></tr>
							<tr><td>Branches</td><td> Multiple </td></tr>
						</table>
					</section>
					<section>
						<table>
							<tr> <th> Pros </th> <th> Cons </th> </tr>
							<tr>
								<td> Features can be worked on independently</td>
								<td> Have to remember to keep feature branches up to date</td>
							</tr>
							<tr>
								<td> Branches can be checked to work before merging into master</td>
								<td> Requires everyone has write access </td>
							</tr>
						</table>
					</section>
					<section>
						<h2>Summary</h2>
						<p>Branching and merging is a good solution when working on a small trusted team. Master branch can be thought of as safe as experimental features can be worked on in feature branches. Works well for hackathons and such.</p>
					</section>
				</section>
				<section>
					<section>
						<h2>Fork and merge</h2>
						<table>
							<caption> Situation </caption>
							<tr><td>Remotes</td><td>#members+1</td></tr>
							<tr><td>Branches</td><td>1-many</td></tr>
						</table>
					</section>
					<section>
						<table>
							<tr> <th> Pros </th> <th> Cons </th> </tr>
							<tr>
								<td>Each person has their own remote, so editing your own history won't mess up other people's repo(this is necessary in some companies that don't like numerous commits that can be squeezed into one</td>
								<td>Have to ensure that the history you modify hasn't hit the upstream repo</td>
							</tr>
							<tr>
								<td>You can do whatever you want to origin without messing up your teammates.</td>
								<td>Need write access to the original repo</td>
							</tr>
						</table>
					</section>
					<section>
						<h2>Summary</h2>
						<p>Forking and merging is seen often on it's own and is more likely to be seen in a hackathon environment. While it provides some benefits in the ability for a user to edit their own history (good if your messing with something that requires API keys) it offers few other benefits.</p>
					</section>
				</section>
				<section>
					<section>
						<h2>Pull requests</h2>
						<table>
							<caption> Situation </caption>
							<tr><td>Remotes</td><td>#members+1</td></tr>
							<tr><td>Branches</td><td>many</td></tr>
						</table>
					</section>
					<section>
						<table>
							<tr> <th> Pros </th> <th> Cons </th> </tr>
							<tr>
								<td>Not all members need access to the original repo(anyone can make a pull request)</td>
								<td>Relies on those with access to original repo to accept your changes(projects can die and needlessly split due to this)</td>
							</tr>
							<tr>
								<td>Allows for a team member to review the code</td>
								<td>Slowest method</td>
							</tr>
							<tr>
								<td>Secure yet open</td>
								<td></td>
							</tr>
						</table>
					</section>
					<section>
						<h2>Summary</h2>
						<p>The most widely used workflow for Git. It combines the other workflows into a secure and useable form that allows trusted users to edit the primary repository while still allowing for open contribution and ensuring good coding practices by encouraging code review. Just remember to create a different branch before making a pull request so you don't get stuck.</p>
					</section>
				</section>
				<section>
					<h2>Let's make a pull request</h2>
					<ul>
						<li>Navigate back to spoon-knife</li>
						<li>Check out a new branch</li>
						<li>Make any changes you deem necessary</li>
						<li>Stage your changes then commit them</li>
						<li>Check the state of origin</li>
						<li>Push your changes to origins</li>
						<li>Make a pull request from your repo on GH</li>
					</ul>
					<h3> Congratulations, you've made your first pull request!</h3>
				</section>
				<section>
					<h2>The final sandbox</h2>

				</section>
				<section>
					<section>
						<h2>FAQ</h2>
						<h3>Frequently asked questions, and concerns</h3>
					</section>
					<section>
						<p>Q: Are merge conflicts as impossible to deal with as they were in software II?</p>
						<p>A: No, Software 2 used SVN which was centralized version control. Merge conflicts are rarer with distributed version control, and are usually not nearly as complex</p>
					</section>
					<section>
						<p>Q: I REALLY don't want to mess up BOBs work by writing to the same file, so should I just copy the file and work on it separately?</p>
						<p>A: No. If you're really concerned about overlapping, create a branch and merge at a later point when you can know it's safe</p>
					</section>
					<section>
						<p>Q: How much should I commit? Should I commit half the project at once or should I commit after every sentence?</p>
						<p>A: It's recommended that commits be atomic and not encompass a large amount of material. E.G. If you've added parsing for a language and implemented an automatic build feature in a project you should add the files(or parts of a file when you're more comfortable with git) and then commit the first part, then add the automatic build code and make it a separate commit</p>
					</section>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
