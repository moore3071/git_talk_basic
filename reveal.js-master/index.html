<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Git and Github- The basics</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>The Basics of Git</h1>
					<h3>An interactive introduction to Git and Github</h3>
					<p>
						<small>Sponsored by the OpenSource Club</small>
					</p>
				</section>

				<section>
					<section>
						<h2>What you should have with you</h2>
						<ul>
							<li>A computer</li>
							<li>Access to a Unix-based terminal</li>
							<li>Git installed <small>check with `git --version`</small></li>
							<li>A Github account</li>
						</ul>
					</section>
					<section>
						<h2>Installing git</h2>
						<table>
							<caption> Linux </caption>
							<tr>
								<th>Distro</th><th>Command</th>
							</tr>
							<tr>
								<td>Debian-based</td><td>#apt-get install git</td>
							</tr>
							<tr>
								<td>Redhat-based based</td><td>#yum install git</td>
							</tr>
							<tr>
								<td>Fedora(22 and on)</td><td>#dnf install git</td>
							</tr>
							<tr>
								<td>Arch</td><td>#pacman -S git</td>
							</tr>
							<tr>
								<td>Gentoo</td><td>#emerge dev-vcs/git</td>
							</tr>
							<caption> Other operating systems </caption>
							<tr>
								<th> OS </th><th>Command</th>
							</tr>
							<tr>
								<td> Mac </td> <td> $git #then follow instructions</td>
							</tr>
							<tr>
								<td> Windows </td> <td> http://git-scm.com/download/win </td>
							</tr>
						</table>
					</section>
					<section>
						<h2>Signing up with GitHub</h2>
						<a href="https://github.com"><img src="github_signup.png" alt="https://github.com"></img></a>
					</section>
				</section>

				<section>
					<section>
						<h2>Traditional approach to Git</h2>
						<img src="xkcd_git.png"></img>
					</section>
					<section>
						<h2>Git is quicksaving</h2>
						<img src="explosmquicksave.png"></img>
					</section>
					<section>
						<h2> Git as quicksaving </h2>
						<table>
							<tr><td>Commit</td><td>Save</td></tr>
							<tr><td>Branches</td><td>Different choices</td></tr>
							<tr><td>Remotes</td><td>Saves from other people</td></tr>
						</table>
					</section>
					<section>
						<h2> Where the analogy breaks </h2>
						<ul>
							<li>Saves(commits) are easily combined with the saves(commits) from other choices</li>
							<li>People are usually sharing their saves(commits)</li>
							<li>You have to specify what to save</li>
						</ul>
					</section>
				</section>

				<section>
					<section>
						<h2>Let's start using Git</h2>
						<ol>
							<li> make a directory for today's repos <code> $mkdir git_talk_repos</code></li>
							<li> go to this directory <code> $cd git_talk_repos</code></li>
							<li> Fork the repo at github.com/octocat/Spoon-Knife  on the website GitHub</li>
							<li> Clone the repository to your copy <code> git clone https://github.com/userName/Spoon-Knife.git</code></li>
							<li> Add the remote "upstream" to your local version <code> git remote add upstream https://github.com/octocat/Spoon-Knife.git</code></li>
						</ol>
					</section>
					<section>
						<h1>What did we just do?</h1>
						<ul>
							<li> Forking </li>
							<li> Cloning </li>
							<li> Remotes </li>
						</ul>
					</section>
					<section>
						<h2>Forking</h2>
						<p> <b>You (generally) can't write to repos you don't own on Github</b>. Forking gives you a version of the code also on Github that you can maintain and modify</p>
					</section>
					<section>
						<h2>Cloning</h2>
						<p>Cloning puts the project on your computer and allows you to commnicate with the repo you cloned.</p>
					</section>
					<section>
						<h2>Remotes</h2>
						<p>different sources from which you get your code. Generally if you've forked a project you'll need to get more up to date  versions of the code from the original repo (usually the upstream remote).</p>
					</section>
				</section>

				<section>
					<section>
						<h2>Visualizing Git</h2>
						Add images to this slide set
					</section>
				</section>

				<section>
					Add Git commands and explanations here
				</section>

				<section>
					<h2>Common Git commands</h2>
					<ul>
						<li>git add</li>
						<li>git rm</li>
						<li>git commit</li>
						<li>git fetch</li>
						<li>git merge</li>
						<li>git pull</li>
						<li>git rebase</li>
					</ul>
				</section>

				<section>
					<section>
						<h2>Git add</h2>
						<code>$git add &lt;file&gt;</code>
						<p>Adds a modified or new file to be staged in order to be committed.</p>
					</section>
				</section>

				<section>
					<section>
						<h2>Git rm</h2>
						<code>$git rm &lt;file&gt;</code>
						<p>Stages a file to be removed in the next commit.</p>
					</section>
				</section>

				<section>
					<section>
						<h2>Git commit</h2>
						<code>$git commit &lt;remote&gt; &lt;branch&gt;</code>
						<p>Makes a "save" of the currently staged changes</p>
					</section>
				</section>

				<section>
					<section>
						<h2>Git fetch</h2>
						<code>$git fetch &lt;remote&gt; &lt;branch&gt;</code>
						<p>Retrieves the state of &lt;branch&gt; in the remote repository &lt;remote&gt; which can then be compared with the local repository</p>
					</section>
				</section>

				<section>
					<section>
						<h2>Git merge</h2>
						<code>$git merge &lt;branch&gt;</code>
						<p>Merges the changes from &lt;branch&gt; into the current branch and moves the current branch's pointer to the merged commit. Note that the pointer for &lt;branch&gt; remains where it was before.</p>
					</section>
				</section>

				<section>
					<section>
						<h2>Git pull</h2>
						<code>$git pull &lt;remote&gt; &lt;branch&gt;</code>
						<p>Runs a combination of git fetch and git merge. First it fetches the changes from &lt;remote&gt; &lt;branch&gt; and merges them into your local branch of the name &lt;branch&gt; (creating it if it doesn't exist).</p>
					</section>
				</section>

				<section>
					<section>
						<h2>Git rebase</h2>
						<p>I need to research this myself</p>
					</section>
				</section>

				<section>
					<h1> Basic workflows on Github </h1>
					<ul>
						<li>Naive approach</li>
						<li>Branch and merge</li>
						<li>Fork and merge</li>
						<li>Pull requests</li>
					</ul>
				</section>

				<section>
					<section>
						<h2>Naive approach</h2>
						<table>
							<caption>Situation</caption>
							<tr><td>Remotes</td><td> 1</td></tr>
							<tr><td>Branches</td><td> 1</td></tr>
						</table>
					</section>
					<section>
						<table>
							<tr> <th> Pros </th> <th> Cons </th> </tr>
							<tr>
								<td> Simple </td>
								<td> More frequent merge conflicts </td>
							</tr>
							<tr>
								<td> </td>
								<td> Requires everyone has write access </td>
							</tr>
							<tr>
								<td></td>
								<td>Master/production can be disabled for time </td>
							</tr>
						</table>
					</section>
					<section>
						<h2>Summary</h2>
						<p>The naive approach is ideal for simple projects involving one user (think version controlling your school notes and homework), but is extremely problematic for most other projects.</p>
					</section>
				</section>
				<section>
					<section>
						<h2>Branch and merge</h2>
						<table>
							<caption> Situation </caption>
							<tr><td>Remotes</td><td> 1 </td></tr>
							<tr><td>Branches</td><td> Multiple </td></tr>
						</table>
					</section>
					<section>
						<table>
							<tr> <th> Pros </th> <th> Cons </th> </tr>
							<tr>
								<td> Features can be worked on independently</td>
								<td> Have to remember to keep feature branches up to date</td>
							</tr>
							<tr>
								<td> Branches can be checked to work before merging into master</td>
								<td> Requires everyone has write access </td>
							</tr>
						</table>
					</section>
					<section>
						<h2>Summary</h2>
						<p>Branching and merging is a good solution when working on a small trusted team. Master branch can be thought of as safe as experimental features can be worked on in feature branches. Works well for hackathons and such.</p>
					</section>
				</section>
				<section>
					<section>
						<h2>Fork and merge</h2>
						<table>
							<caption> Situation </caption>
							<tr><td>Remotes</td><td>#members+1</td></tr>
							<tr><td>Branches</td><td>1-many</td></tr>
						</table>
					</section>
					<section>
						<table>
							<tr> <th> Pros </th> <th> Cons </th> </tr>
							<tr>
								<td>Each person has their own remote, so editing your own history won't mess up other people's repo(this is necessary in some companies that don't like numerous commits that can be squeezed into one</td>
								<td>Have to ensure that the history you modify hasn't hit the upstream repo</td>
							</tr>
							<tr>
								<td>You can do whatever you want to origin without messing up your teammates.</td>
								<td>Need write access to the original repo</td>
							</tr>
						</table>
					</section>
					<section>
						<h2>Summary</h2>
						<p>Forking and merging is seen often on it's own and is more likely to be seen in a hackathon environment. While it provides some benefits in the ability for a user to edit their own history (good if your messing with something that requires API keys) it offers few other benefits.</p>
					</section>
				</section>
				<section>
					<section>
						<h2>Pull requests</h2>
						<table>
							<caption> Situation </caption>
							<tr><td>Remotes</td><td>#members+1</td></tr>
							<tr><td>Branches</td><td>many</td></tr>
						</table>
					</section>
					<section>
						<table>
							<tr> <th> Pros </th> <th> Cons </th> </tr>
							<tr>
								<td>Not all members need access to the original repo(anyone can make a pull request)</td>
								<td>Relies on those with access to original repo to accept your changes(projects can die and needlessly split due to this)</td>
							</tr>
							<tr>
								<td>Allows for a team member to review the code</td>
								<td>Slowest method</td>
							</tr>
							<tr>
								<td>Secure yet open</td>
								<td></td>
							</tr>
						</table>
					</section>
					<section>
						<h2>Summary</h2>
						<p>The most widely used workflow for Git. It combines the other workflows into a secure and useable form that allows trusted users to edit the primary repository while still allowing for open contribution and ensuring good coding practices by encouraging code review. Just remember to create a different branch before making a pull request so you don't get stuck.</p>
					</section>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
